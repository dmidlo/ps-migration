function New-DbHashRef {
    param(
        [Parameter(Mandatory)]
        $DbDocument,

        [Parameter(Mandatory)]
        $Collection,

        [Parameter(Mandatory)]
        $RefCollection
    )

    # I know this is weird, but it's the way refs work (just) for now.
    # So, The $Collection and $RefCollection input params make sense 
    # in as far as naming regarding domain context (LiteDB Convention 
    # translated to powershell param naming).  The moniker 'Ref' should
    # signify the reference collection.  We have a naming conflict when
    # we look at the properties of RefGuid and RefCol, which are used
    # for 'this DbRef's Guid and home colletion.  Guid is a reference to 
    # the application object's version collection, $Hash is a reference
    # to the member of that object's version collection, and again, 
    # according to LiteDB convention, $Ref is reserved for the target
    # collection to reference. $Guid refs generated by New-DbGuidRef
    # are subject to the self same, $Guid, and guidRefs generated there
    # point to Application Object Version collections, but RefGuid and
    # RefCol treated the same in that function's object.
    #
    # If you're using the function RefCollection sticks to the domain
    # convetion, so should you.
    #
    # If you're maintaining the function, internally the prefex of
    # `Ref` indicates a property owned by `this` DbRef object.
    $out = [PSCustomObject]@{
        RefGuid = [Guid]::NewGuid()
        RefCol = $Collection.Name
        Guid = $DbDocument.Guid
        "`$Hash"  = $DbDocument.Hash
        "`$Ref" = $RefCollection.Name
    }
    $Hash = (Get-DataHash -DataObject $out -FieldsToIgnore @('_id', 'Hash', 'Count', 'Length', 'Collection')).Hash
    $out = ($out | Add-Member -MemberType NoteProperty -Name "Hash" -Value $Hash -Force -PassThru)
    
    return $out
}
